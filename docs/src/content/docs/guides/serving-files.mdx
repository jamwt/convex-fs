---
title: Serving files
description: How to serve and download files from ConvexFS.
---

import { Aside } from "@astrojs/starlight/components";

Serving files with ConvexFS is done via two steps:

1. You write a normal Convex query that uses `fs.stat` to get the file metadata,
   including the `blobId`. This is used to construct a URL that points to the
   component's blob HTTP endpoint. In our examples, this is mounted at
   `/fs/blobs/{blobId}`.
2. Use this URL in your frontend to download or render the file. You can use it
   in `<img>` tags or any other HTML element that supports the `src` attribute.

## Using buildDownloadUrl

ConvexFS exports a `buildDownloadUrl` helper function that constructs download
URLs with the correct format. **We recommend always including the `path`
parameter**, which enables server-side validation that the file exists and the
blobId matches:

```tsx
import { query } from "./_generated/server";
import { v } from "convex/values";
import { buildDownloadUrl } from "convex-fs";
import { fs } from "./fs";

export const getFileUrl = query({
  args: { path: v.string() },
  handler: async (ctx, args) => {
    const siteUrl = process.env.CONVEX_SITE_URL!;
    const file = await fs.stat(ctx, args.path);
    if (!file) {
      return null;
    }
    // Include the path for server-side validation
    return buildDownloadUrl(siteUrl, "/fs", file.blobId, args.path);
  },
});
```

<Aside type="tip">
  Including the `path` parameter adds an extra layer of security. When a user
  requests the download URL, the server verifies that the file still exists at
  that path and that the blobId matches. This prevents issues like: - Users
  accessing files via bookmarked URLs after the file has been deleted - Users
  guessing or enumerating blobIds to access arbitrary files
</Aside>

You can also use `buildDownloadUrl` directly in your frontend if you already
have the file metadata:

```tsx
import { buildDownloadUrl } from "convex-fs";

function ImageGallery({ images, siteUrl }: Props) {
  return (
    <div>
      {images.map((image) => (
        <img
          key={image.path}
          src={buildDownloadUrl(siteUrl, "/fs", image.blobId, image.path)}
          alt={image.path}
        />
      ))}
    </div>
  );
}
```

## Example Image component

```tsx
import { useQuery } from "convex/react";
import { api } from "../convex/_generated/api";

function Image({ path }: { path: string }) {
  const url = useQuery(api.files.getFileUrl, { path });
  return <img src={url} alt={path} />;
}
```

<Aside type="tip">Clearly `<img>` elements are not reactive if given a static
URL. However, when you subscribe to the blob URL for the file path, as in this
example, the image will be re-rendered when the file contents are updated
because the URL will change.</Aside>

## ...but doesn't a CDN serve the file contents?

Yes! Perhaps surprisingly, the ConvexFS blob endpoint does not actually serve
the file contents. Instead, it returns a 302 redirect to the appropriate signed
CDN URL. Then the file contents are served from bunny.net's global CDN, which is
optimized for fast delivery to users all over the world.

Additionally, the cache `max-age` timings are coordinated between the
component's 302 response and the CDN's token expiration. This means the file's
cached content will continue to be used without asking the Convex deployment to
regenerate URLs over and over again. But the browser will come back to Convex
before the CDN URL becomes invalid.

## Personal tokens, but globally cached values.

Every CDN token generated by the component is one-time use. This means that if
you revoke access to the resource for a particular user, no more tokens will be
issued when their one-time use token expires.

However, while the CDN URL is invalid, the cached blob is not. bunny.net's CDN
does not include the token in the CDN cache key. So the blob will continue to be
in a high-performance edge cache for those users who continue to have access.

In other words, authorization is fine grained, but the cache is shared. This
provides a great balance between security and performance.

## What's next

We know how to get files into ConvexFS, and how to serve them to our apps.

But what else can we do to
[evolve our file system over time](/guides/filesystem-operations)?
